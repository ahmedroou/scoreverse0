
rules_version = '2';

service cloud.firestore {
  match /databases/{database}/documents {

    // Helper functions
    function isSignedIn() {
      return request.auth != null;
    }
    
    function isOwner(userId) {
      return request.auth.uid == userId;
    }

    function isAdmin() {
      return isSignedIn() &&
             exists(/databases/$(database)/documents/users/$(request.auth.uid)) &&
             get(/databases/$(database)/documents/users/$(request.auth.uid)).data.isAdmin == true;
    }

    // Default deny all reads and writes
    match /{path=**} {
      allow read, write: if false;
    }

    // PUBLIC COLLECTIONS
    match /public_shares/{shareId} {
      allow read: if true;
    }

    match /spaceInvites/{inviteCode} {
      allow read: if isSignedIn();
      allow create: if isSignedIn() && request.resource.data.ownerId == request.auth.uid;
    }
    
    // USER-SPECIFIC DATA & SUBCOLLECTIONS
    match /users/{userId}/{path=**} {
      // Allow owner full access to their own documents and subcollections
      allow read, write: if isSignedIn() && isOwner(userId);
    }
    
    // Allow Admins to read all user data
    match /users/{userId}/{path=**} {
        allow read: if isAdmin();
    }
    
    // RULES FOR SHARED ACCESS

    // Rule for JOINING a space
    match /users/{ownerId}/spaces/{spaceId} {
      allow update: if isSignedIn() &&
                       !isOwner(ownerId) && // User cannot join their own space this way
                       request.resource.data.diff(resource.data).affectedKeys().hasOnly(['members']) &&
                       request.resource.data.members.diff(resource.data.members).affectedKeys().hasOnly([request.auth.uid]) &&
                       request.resource.data.members[request.auth.uid] == 'viewer' &&
                       // This handles new joins, and rejoins after being removed.
                       (resource.data.members == null || !(request.auth.uid in resource.data.members));
    }
    
    // Rule for READING shared data
    match /users/{ownerId}/{collection}/{docId} {
        // A member of a space can read data associated with that space.
        allow read: if isSignedIn() &&
                       // This rule applies to matches and tournaments which have a spaceId
                       (collection == 'matches' || collection == 'tournaments') &&
                       resource.data.spaceId != null &&
                       // Verify the user is a member of the space they're trying to read from
                       get(/databases/$(database)/documents/users/$(ownerId)/spaces/$(resource.data.spaceId)).data.members[request.auth.uid] != null;
        
        // A member of a space can also read the owner's global 'games' and 'players' collections.
        // This is a complex permission. The simplest way to enforce this is to check if the user
        // is a member of *any* of the owner's spaces. This is inefficient but functional.
        // A better data model would make this check easier.
        allow read: if isSignedIn() &&
                       (collection == 'games' || collection == 'players') &&
                       // We can't efficiently check all spaces, so we check the user's own doc.
                       // We check if the ownerId they are trying to read from is listed in their sharedSpaces map.
                       ownerId in get(/databases/$(database)/documents/users/$(request.auth.uid)).data.sharedSpaces.values();
                       // NOTE: .values() is not supported in Firestore rules.
                       // The read will fail, and client must handle it. This rule is effectively non-functional
                       // until the data model is changed or a workaround is found.
                       // For now, access to shared players/games relies on the client already having that data.
                       // The primary goal is to fix the JOIN functionality.
    }
  }
}
